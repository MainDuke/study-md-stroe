문제는 이렇습니다. N칸의 1차원 배열이 있을 때, 부분 배열 중 그 원소 합이 M이 되는 경우의 수를 구하여라...

모든 경우의 수를 다 테스트해 본다면, 구간 합을 구간합 배열로 O(1)만에 구한다고 해도 경우의 수가 이미 O(N^2)라 fail입니다.

포인터 2개를 준비합니다. (lo, hi), (l, r), (p, q), (s, e) 등등 명칭은 자유인데 저는 s, e로 하죠.

맨 처음에는 s = e = 0이며, 항상 s <= e여야 합니다.

저는 s가 가리키는 칸은 포함되고, e가 가리키는 칸은 포함되지 않도록 기준을 잡겠습니다.

s = e일 경우 그건 크기가 0인, 아무것도 포함하지 않는 부분 배열을 뜻합니다.

이제 다음의 과정을 s < N인 동안 반복합니다.

① 만약 현재 부분합이 M 이상이거나, 이미 e = N이면 s++

② 그렇지 않다면 e++

③ 현재 부분합이 M과 같으면 결과 ++
참고 : https://m.blog.naver.com/kks227/220795165570

~~~
정리
1. 2포인터 알고리즘은, 2개의 포인터를 이용해서 조건을 정해서 움직이는것!
2. 문제에 따라서, 2개의 포인터를 이용해서 모든 경우의 수를 검색했는가 를 증명해야함.
3. 슬라이딩 윈도우 라는 테크닉도 있다고 함.
~~~
